import { basename, dirname, relative } from "node:path";

import { unified } from "unified";
import remarkParse from "remark-parse";

export const AI_RULES_BEGIN_MARKER = "<!-- AI-INIT:RULES:BEGIN -->";
export const AI_RULES_END_MARKER = "<!-- AI-INIT:RULES:END -->";

function escapeRegExp(value: string): string {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function toPosixPath(value: string): string {
  return value.split("\\").join("/");
}

function toRelativeLink(targetFilePath: string, absoluteRuleFilePath: string): string {
  const rel = toPosixPath(relative(dirname(targetFilePath), absoluteRuleFilePath));
  if (rel.startsWith(".")) {
    return rel;
  }
  return `./${rel}`;
}

function buildManagedBlock(relativeRulePaths: string[]): string {
  const lines: string[] = [];
  lines.push(AI_RULES_BEGIN_MARKER);
  lines.push("## AI Rules");
  lines.push("");
  lines.push("Generated by `ai-init`. Do not edit manually inside this block.");
  lines.push("");

  for (const rulePath of relativeRulePaths) {
    const label = basename(rulePath, ".md");
    lines.push(`- [${label}](${rulePath})`);
  }

  if (relativeRulePaths.length === 0) {
    lines.push("- No active rule files selected.");
  }

  lines.push(AI_RULES_END_MARKER);
  return lines.join("\n");
}

function ensureLeadingSkeleton(content: string, targetFileName: string): string {
  if (content.trim().length > 0) {
    return content;
  }
  return `# ${targetFileName}\n\n`;
}

function hasManagedBlock(content: string): boolean {
  return content.includes(AI_RULES_BEGIN_MARKER) && content.includes(AI_RULES_END_MARKER);
}

function replaceManagedBlock(content: string, block: string): string {
  const pattern = new RegExp(
    `${escapeRegExp(AI_RULES_BEGIN_MARKER)}[\\s\\S]*?${escapeRegExp(AI_RULES_END_MARKER)}`,
    "m",
  );
  return content.replace(pattern, block);
}

function appendManagedBlock(content: string, block: string): string {
  return `${content.trimEnd()}\n\n${block}\n`;
}

async function isMarkdownParseable(content: string): Promise<boolean> {
  try {
    unified().use(remarkParse).parse(content);
    return true;
  } catch {
    return false;
  }
}

export async function updateInstructionsFile(args: {
  targetFilePath: string;
  targetFileName: "AGENTS.md" | "CLAUDE.md";
  absoluteRuleFilePaths: string[];
}): Promise<{ updatedLinks: string[] }> {
  const { targetFilePath, targetFileName, absoluteRuleFilePaths } = args;

  const file = Bun.file(targetFilePath);
  const exists = await file.exists();
  let content = exists ? await file.text() : "";
  content = ensureLeadingSkeleton(content, targetFileName);

  const relativeRulePaths = absoluteRuleFilePaths
    .map((rulePath) => toRelativeLink(targetFilePath, rulePath))
    .sort((left, right) => left.localeCompare(right));

  const managedBlock = buildManagedBlock(relativeRulePaths);
  const parseable = await isMarkdownParseable(content);

  let nextContent: string;
  if (hasManagedBlock(content)) {
    nextContent = replaceManagedBlock(content, managedBlock);
  } else if (parseable) {
    nextContent = appendManagedBlock(content, managedBlock);
  } else {
    nextContent = appendManagedBlock(content, managedBlock);
  }

  await Bun.write(targetFilePath, nextContent);

  return { updatedLinks: relativeRulePaths };
}

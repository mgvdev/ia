import type { CategoryDefinition } from "../types.ts";

export function renderRuleFileMarkdown(args: {
  category: CategoryDefinition;
  selectedRuleOptions: Record<string, string[]>;
  selectedRuleNotes?: Record<string, string>;
  generatedAt: string;
}): string {
  const { category, selectedRuleOptions, selectedRuleNotes = {}, generatedAt } = args;

  const lines: string[] = [];
  lines.push(`# ${category.label} Rules`);
  lines.push("");
  lines.push("Generated by `ai-init`. This file is managed by tooling.");
  lines.push("");
  lines.push(`- Category: \`${category.id}\``);
  lines.push(`- Generated at: \`${generatedAt}\``);
  lines.push("");

  for (const rule of category.rules) {
    const selectedIds = selectedRuleOptions[rule.id] ?? [];
    const customInstruction = (selectedRuleNotes[rule.id] ?? "").trim();
    if (selectedIds.length === 0 && customInstruction.length === 0) {
      continue;
    }

    lines.push(`## ${rule.label}`);
    lines.push("");
    lines.push(rule.description);
    lines.push("");

    for (const optionId of selectedIds) {
      const option = rule.options.find((candidate) => candidate.id === optionId);
      if (!option) {
        continue;
      }
      lines.push(`- **${option.label}**: ${option.emits}`);
    }

    if (customInstruction.length > 0) {
      const normalized = customInstruction.replace(/\s+/g, " ");
      lines.push(`- **Custom instruction**: ${normalized}`);
    }

    lines.push("");
    lines.push("### Rationale");
    lines.push("");
    lines.push("- These selections define default implementation constraints for this category.");
    lines.push("- Deviations should be explicitly documented when needed.");
    lines.push("");
  }

  return `${lines.join("\n").trimEnd()}\n`;
}
